#pragma once
#ifndef BIOS_H
#define BIOS_H

#include <mem.h>
#include <conio.h>
#include "stdbool.h"

//#include "dos3_3.h"
//#include "freedos.h"
#include "DOS.h"
#include "cpu8086.h"
#include "disk.h"
#include "ports.h"

int cursor_x = 0;
int cursor_y = 0;
int color = 7;

uint8_t VRAM[VRAM_SIZE << 10];

static void bios_putchar(const char c) {
    //printf("\033[%im%c", color, c);
    if (c == 0x0D) {
        cursor_x = 0;
        cursor_y++;
    } else if (c == 0x0A) {
        cursor_x = 0;
    } else if (c == 0x08 && cursor_x > 0) {
        cursor_x--;
        VRAM[/*0xB8000 + */(cursor_y * 160) + cursor_x * 2 + 0] = 32;
        VRAM[/*0xB8000 + */(cursor_y * 160) + cursor_x * 2 + 1] = color;
    } else {
        VRAM[/*0xB8000 + */(cursor_y * 160) + cursor_x * 2 + 0] = c & 0xFF;
        VRAM[/*0xB8000 + */(cursor_y * 160) + cursor_x * 2 + 1] = color;
        if (cursor_x == 79) {
            cursor_x = 0;
            cursor_y++;
        } else
            cursor_x++;
    }

    if (cursor_y == 25) {
        cursor_y = 24;

        memmove(VRAM/* + 0xB8000*/, VRAM /*+ 0xB8000*/ + 160, 80 * 25 * 2);
        for (int a = 0; a < 80; a++) {
            VRAM[/*0xB8000 + */24 * 160 + a * 2 + 0] = 32;
            VRAM[/*0xB8000 + */24 * 160 + a * 2 + 1] = color;

        }
    }
}

static void bios_putstr(const char *s) {
    while (*s)
        bios_putchar(*s++);
}

#define bios_printf(...)                    \
    do {                            \
        char _buf_[4096];                \
        snprintf(_buf_, sizeof(_buf_), __VA_ARGS__);    \
        bios_putstr(_buf_);                \
    } while (0)


static void kbd_set_mod0 ( int mask, int scan )
{
    if ((scan & 0x80))
        RAM[0x417] &= ~mask;
    else
        RAM[0x417] |= mask;
}

static const uint8_t scan2ascii[] = {
        //0    1     2      3     4     5     6     7     8    9     A      B     C    D     E     F
        0x00, 0x1B, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x2D, 0x3D, 0x08, 0x09,
        0x71, 0x77, 0x65, 0x72, 0x74, 0x79, 0x75, 0x69, 0x6F, 0x70, 0x5B, 0x5D, 0x0D, 0x00, 0x61, 0x73,
        0x64, 0x66, 0x67, 0x68, 0x6A, 0x6B, 0x6C, 0x3B, 0x27, 0x60, 0x00, 0x5C, 0x7A, 0x78, 0x63, 0x76,
        0x62, 0x6E, 0x6D, 0x2C, 0x2E, 0x2F, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x7F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00,


        0x00, 0x37, 0x2E, 0x20, 0x2F, 0x30, 0x31, 0x21, 0x32, 0x33, 0x34, 0x35, 0x22, 0x36, 0x38, 0x3E,
        0x11, 0x17, 0x05, 0x12,	0x14, 0x19, 0x15, 0x09,	0x0F, 0x10, 0x39, 0x3A,	0x3B, 0x84, 0x61, 0x13,
        0x04, 0x06, 0x07, 0x08,	0x0A, 0x0B, 0x0C, 0x3F,	0x40, 0x41, 0x82, 0x3C,	0x1A, 0x18, 0x03, 0x16,
        0x02, 0x0E, 0x0D, 0x42,	0x43, 0x44, 0x81, 0x3D,	0x88, 0x2D, 0xC0, 0x23,	0x24, 0x25, 0x26, 0x27,
        0x28, 0x29, 0x2A, 0x2B,	0x2C, 0xA0, 0x90
#if 0
        0x00, 0x37, 0x2E, 0x20, 0x2F, 0x30, 0x31, 0x21, 0x32, 0x33, 0x34, 0x35, 0x22, 0x36, 0x38, 0x3E,
	0x11, 0x17, 0x05, 0x12,	0x14, 0x19, 0x15, 0x09,	0x0F, 0x10, 0x39, 0x3A,	0x3B, 0x84, 0x01, 0x13,
	0x04, 0x06, 0x07, 0x08,	0x0A, 0x0B, 0x0C, 0x3F,	0x40, 0x41, 0x82, 0x3C,	0x1A, 0x18, 0x03, 0x16,
	0x02, 0x0E, 0x0D, 0x42,	0x43, 0x44, 0x81, 0x3D,	0x88, 0x2D, 0xC0, 0x23,	0x24, 0x25, 0x26, 0x27,
	0x28, 0x29, 0x2A, 0x2B,	0x2C, 0xA0, 0x90
#endif
};

static int kbd_push_buffer ( uint16_t data )
{
    uint16_t buftail = peekw(0x41C);
    uint16_t buftail_adv = buftail + 2;
    if (buftail_adv == peekw(0x482))
        buftail_adv = peekw(0x480);
    if (buftail_adv == peekw(0x41A))
        return 1;		// buffer is full!
    pokew(0x400 + buftail, data);
    pokew(0x41C, buftail_adv);
    return 0;
}

static uint16_t kbd_get_buffer ( int to_remove )
{
    uint16_t bufhead = peekw(0x41A);
    if (bufhead == peekw(0x41C))
        return 0;	// no character is available in the buffer
    uint16_t data = peekw(0x400 + bufhead);
    if (!to_remove)
        return data;
    bufhead += 2;
    if (bufhead == peekw(0x482))
        pokew(0x41A, peekw(0x480));
    else
        pokew(0x41A, bufhead);
    return data;
}


// This is the IRQ handler for the keyboard interrupt of BIOS
static void bios_irq1_handler(void) {
    // keyboard
    //puts("BIOS: IRQ1!\r\n");
    /* FIXME!! */
   //	if ((portram[0x64] & 2)) {	// is input buffer full
       //uint8_t scan = portram[0x60];	// read the scancode
       uint8_t scan = portin(0x60);
       uint8_t ctrlst = portin(0x61);
       portout(0x61, ctrlst | 0x80);
       portout(0x61, ctrlst);
       //portram[0x64] &= ~2;		// empty the buffer
       //printf("BIOS: scan got: %Xh\n", scan);
       switch (scan & 0x7F) {
           case 0x36: kbd_set_mod0(0x01, scan); break;	// rshift
           case 0x2A: kbd_set_mod0(0x02, scan); break;	// lshift
           case 0x1D: kbd_set_mod0(0x04, scan); break;	// ctrl
           case 0x38: kbd_set_mod0(0x08, scan); break;	// alt
           case 0x46: kbd_set_mod0(0x10, scan); break;	// scroll lock
           case 0x45: kbd_set_mod0(0x20, scan); break;	// num lock
           case 0x3A: kbd_set_mod0(0x40, scan); break;	// caps lock
           case 0x52: kbd_set_mod0(0x80, scan); break;	// ins
           default:
               if (scan < 0x80) {
                   uint8_t ascii;
                   if (scan <= sizeof(scan2ascii))
                       ascii = scan2ascii[scan];
                   else
                       ascii = 0;
                   if ((RAM[0x417] & 3)) {
                       if (ascii == ';')
                           ascii = ':';
                   }
                   kbd_push_buffer(ascii | (scan << 8));
               }
               break;
       }
   //	}
       portout(0x20, 0x20);	// send end-of-interrupt command to the interrupt controller
       /* */
}


int cpu_hlt_handler(void) {
    puts("BIOS: critical warning, HLT outside of trap area?!\r\n");
    return 1;    // Yes, it was really a halt, since it does not fit into our trap area
}

#endif